# Analytics Update: Collectible Fragments Design Document

**Date**: December 2025  
**Feature**: Support for empty/collectible fragments in workout definitions  
**Status**: ðŸ“‹ Design Phase

---

## Executive Summary

This document outlines the design for extending WodWiki's fragment system to support **collectible fragments** â€” fragments that are defined in the workout syntax but have no predetermined value. These fragments signal that data needs to be collected either:

1. **During runtime execution** â€” Values generated automatically (e.g., elapsed time)
2. **Post-workout in analytics** â€” Values entered manually by the user

This feature enables more flexible workout definitions and richer analytics capabilities.

---

## Problem Statement

Currently, fragments in WodWiki represent **fully specified values**:
- `10` reps â†’ RepFragment with value=10
- `5:00` timer â†’ TimerFragment with value=300000ms
- `100m` distance â†’ DistanceFragment with value={amount: 100, units: 'm'}

However, many workout scenarios require fragments where:
- The **value is unknown at definition time** (e.g., "For Time" workouts where elapsed time is the result)
- The **value should be collected post-workout** (e.g., actual reps completed in an AMRAP)
- The **user wants to track but not prescribe** (e.g., recording weight used without specifying it)

### Example Use Cases

```wod
# Use Case 1: "For Time" workout - elapsed time collected at completion
(3 rounds)
  21 Thrusters 95lb
  15 Pull-ups
[:Finish] ?  # <- Collect total elapsed time when finished

# Use Case 2: AMRAP with collectible rounds
20:00
  (AMRAP)
    5 Pull-ups
    10 Push-ups  
    15 Air Squats
  ? rounds  # <- How many rounds completed? Collected at end

# Use Case 3: Max effort with collectible weight
? lb Deadlift  # <- User enters actual weight used in analytics

# Use Case 4: Flexible rep tracking
? Burpees  # <- User enters how many they actually did
```

---

## Proposed Solution

### 1. Fragment Value State Model

Extend the `ICodeFragment` interface to support a **value collection state**:

```typescript
// Updated ICodeFragment interface
export interface ICodeFragment {
  readonly image?: string;
  readonly value?: any;
  readonly type: string;
  readonly meta?: CodeMetadata;
  readonly fragmentType: FragmentType;
  
  // NEW: Collection state for collectible fragments
  readonly collectionState?: FragmentCollectionState;
}

// New enum for fragment collection state
export enum FragmentCollectionState {
  /** Value is fully specified (current behavior) */
  Defined = 'defined',
  
  /** Value should be generated by runtime (e.g., elapsed time) */
  RuntimeGenerated = 'runtime-generated',
  
  /** Value should be collected from user input (e.g., actual reps) */
  UserCollected = 'user-collected',
  
  /** Value is collected and populated */
  Collected = 'collected'
}
```

### 2. Parser Updates for `?` Placeholder

The parser already has a `QuestionSymbol` token defined (`/\?/`). We need to extend the visitor to recognize `?` in place of numeric values.

#### Token Support (Already Exists)
```typescript
// In timer.tokens.ts - ALREADY EXISTS
export const QuestionSymbol = createToken({
  name: "QuestionSymbol",
  pattern: /\?/,
});
```

#### Parser Rule Updates

```typescript
// In timer.parser.ts - Add ? support to numeric fragments
reps(ctx: any): RepFragment[] {
  if (ctx.QuestionSymbol) {
    const meta = this.getMeta([ctx.QuestionSymbol[0]]);
    return [new CollectibleRepFragment(undefined, meta)];
  }
  const meta = this.getMeta([ctx.Number[0]]);
  return [new RepFragment(ctx.Number[0].image * 1, meta)];
}

// Similar updates for resistance, distance, rounds
resistance(ctx: any): ResistanceFragment[] {
  let load: number | undefined;
  let isCollectible = false;
  
  if (ctx.QuestionSymbol) {
    load = undefined;
    isCollectible = true;
  } else if (ctx.Number && ctx.Number.length > 0) {
    load = ctx.Number[0].image * 1;
  }
  
  let units = (ctx.Weight && ctx.Weight[0].image) || "";
  let meta = this.getMeta([ctx.QuestionSymbol?.[0] ?? ctx.Number[0], ctx.Weight[0]]);
  
  return [new ResistanceFragment(load, units, meta, isCollectible)];
}
```

#### Visitor Grammar Updates

Update the grammar rules to accept `?` as an alternative to numbers:

```typescript
// In timer.parser.ts - Parser rules
$.RULE("reps", () => {
  $.OR([
    { ALT: () => $.CONSUME(QuestionSymbol) },  // NEW: ? placeholder
    { ALT: () => $.CONSUME(Number) }
  ]);
});

$.RULE("resistance", () => {
  $.OR([
    { ALT: () => $.CONSUME(QuestionSymbol) },  // NEW: ? placeholder
    { ALT: () => $.CONSUME(Number) }
  ]);
  $.OPTION(() => $.CONSUME(Weight));
});

$.RULE("distance", () => {
  $.OR([
    { ALT: () => $.CONSUME(QuestionSymbol) },  // NEW: ? placeholder
    { ALT: () => $.CONSUME(Number) }
  ]);
  $.CONSUME(Distance);
});
```

### 3. Fragment Class Updates

#### Option A: Extend Existing Fragments (Recommended)

Add optional collection state to existing fragment classes:

```typescript
// Updated RepFragment
export class RepFragment implements ICodeFragment {
  readonly value?: number;
  readonly image: string;
  readonly collectionState: FragmentCollectionState;

  constructor(
    public reps?: number, 
    public meta?: CodeMetadata,
    collectionState: FragmentCollectionState = FragmentCollectionState.Defined
  ) { 
    this.value = reps;
    this.image = reps !== undefined ? reps.toString() : '?';
    this.collectionState = reps === undefined 
      ? FragmentCollectionState.UserCollected 
      : collectionState;
  }
  readonly type: string = "rep";
  readonly fragmentType = FragmentType.Rep;
}

// Updated ResistanceFragment
export class ResistanceFragment implements ICodeFragment {
  readonly value: { amount: number | undefined, units: string };
  readonly image: string;
  readonly collectionState: FragmentCollectionState;

  constructor(
    value: number | undefined, 
    public units: string, 
    public meta?: CodeMetadata,
    collectionState: FragmentCollectionState = FragmentCollectionState.Defined
  ) {
    this.value = { amount: value, units: units };
    this.image = value !== undefined ? `${value} ${units}` : `? ${units}`;
    this.collectionState = value === undefined 
      ? FragmentCollectionState.UserCollected 
      : collectionState;
  }
  readonly type: string = "resistance";
  readonly fragmentType = FragmentType.Resistance;
}
```

#### Option B: Create Collectible Fragment Subclasses

Create specialized subclasses for collectible fragments:

```typescript
// Collectible base class
export abstract class CollectibleFragment implements ICodeFragment {
  abstract readonly fragmentType: FragmentType;
  abstract readonly type: string;
  
  readonly collectionState: FragmentCollectionState = FragmentCollectionState.UserCollected;
  readonly value: undefined = undefined;
  readonly image: string = '?';
  
  constructor(public meta?: CodeMetadata) {}
  
  // Method to create a resolved copy with collected value
  abstract withCollectedValue(value: any): ICodeFragment;
}

// Collectible rep fragment
export class CollectibleRepFragment extends CollectibleFragment {
  readonly type: string = "rep";
  readonly fragmentType = FragmentType.Rep;
  
  withCollectedValue(reps: number): RepFragment {
    return new RepFragment(reps, this.meta, FragmentCollectionState.Collected);
  }
}
```

### 4. Runtime-Generated Values

Some fragments should be automatically populated by the runtime during execution:

#### Elapsed Time Collection

For "For Time" workouts, the total elapsed time should be automatically collected:

```typescript
// In MetricCollector or RuntimeMetric extension
export interface RuntimeGeneratedMetric {
  type: 'elapsed-time' | 'total-rounds' | 'total-reps';
  sourceFragment?: ICodeFragment;  // Original collectible fragment
  generatedAt: Date;
  value: number;
  unit: string;
}

// During block completion (e.g., in CompletionBehavior)
if (hasCollectibleTimeFragment(block)) {
  const elapsedTime = calculateElapsedTime(block);
  runtime.metrics.collectGenerated({
    type: 'elapsed-time',
    sourceFragment: collectibleFragment,
    generatedAt: new Date(),
    value: elapsedTime,
    unit: 'ms'
  });
}
```

#### Total Rounds Collection (AMRAP)

```typescript
// In RoundsBlock completion
if (isAmrap && hasCollectibleRoundsFragment(block)) {
  const completedRounds = getCurrentRoundIndex(block);
  runtime.metrics.collectGenerated({
    type: 'total-rounds',
    sourceFragment: collectibleFragment,
    generatedAt: new Date(),
    value: completedRounds,
    unit: 'rounds'
  });
}
```

### 5. Analytics View Updates

The analytics view needs to support:
1. **Displaying** collectible fragments with their collected values
2. **Editing** user-collected values post-workout
3. **Distinguishing** between defined vs collected values visually

#### ExecutionRecord Extension

```typescript
// Extended ExecutionRecord for collectible support
export interface ExecutionRecord {
  id: string;
  blockId: string;
  parentId: string | null;
  type: string;
  label: string;
  startTime: number;
  endTime?: number;
  status: 'active' | 'completed' | 'failed';
  metrics: RuntimeMetric[];
  
  // NEW: Collectible fragment tracking
  collectibleFragments?: CollectedFragmentValue[];
}

export interface CollectedFragmentValue {
  /** Reference to original fragment (via sourceId) */
  fragmentSourceId: string;
  
  /** Fragment type (rep, resistance, distance, etc.) */
  fragmentType: FragmentType;
  
  /** How the value was collected */
  collectionMethod: 'runtime-generated' | 'user-input' | 'imported';
  
  /** The collected value */
  collectedValue: any;
  
  /** When the value was collected/entered */
  collectedAt: Date;
  
  /** Previous values if edited */
  history?: { value: any; timestamp: Date }[];
}
```

#### Analytics UI Component

```typescript
// CollectibleValueEditor component
interface CollectibleValueEditorProps {
  fragmentType: FragmentType;
  currentValue?: any;
  onValueChange: (value: any) => void;
  isEditable: boolean;
  collectionMethod: CollectedFragmentValue['collectionMethod'];
}

function CollectibleValueEditor({
  fragmentType,
  currentValue,
  onValueChange,
  isEditable,
  collectionMethod
}: CollectibleValueEditorProps) {
  const formatValue = () => {
    if (currentValue === undefined) return 'â€”';
    switch (fragmentType) {
      case FragmentType.Rep:
        return `${currentValue} reps`;
      case FragmentType.Resistance:
        return `${currentValue.amount} ${currentValue.units}`;
      case FragmentType.Distance:
        return `${currentValue.amount} ${currentValue.units}`;
      case FragmentType.Timer:
        return formatDuration(currentValue);
      default:
        return String(currentValue);
    }
  };

  return (
    <div className="collectible-value">
      {isEditable ? (
        <input 
          type="number" 
          value={currentValue ?? ''} 
          onChange={e => onValueChange(parseValue(e.target.value, fragmentType))}
          placeholder="Enter value"
        />
      ) : (
        <span className={`value ${collectionMethod}`}>
          {formatValue()}
          {collectionMethod === 'runtime-generated' && (
            <span className="badge">Auto</span>
          )}
        </span>
      )}
    </div>
  );
}
```

---

## Implementation Plan

### Phase 1: Fragment System Foundation (Week 1)

1. **Add `FragmentCollectionState` enum** to `src/core/models/CodeFragment.ts`
2. **Update `ICodeFragment` interface** with optional `collectionState` property
3. **Update existing fragment classes** to support collection state:
   - `RepFragment`
   - `ResistanceFragment`
   - `DistanceFragment`
   - `RoundsFragment`
   - `TimerFragment`
4. **Add unit tests** for fragment collection states

### Phase 2: Parser Updates (Week 2)

1. **Update parser grammar** to accept `?` in place of numbers
2. **Update visitor** to create fragments with appropriate collection state
3. **Add parser tests** for `?` placeholder syntax
4. **Update syntax documentation** with new placeholder syntax

### Phase 3: Runtime Integration (Week 3)

1. **Extend `RuntimeMetric`** with collection state tracking
2. **Update `MetricCollector`** to handle collectible fragments
3. **Add runtime-generated value collection** for:
   - Elapsed time (For Time workouts)
   - Total rounds (AMRAP workouts)
   - Total reps (if needed)
4. **Add integration tests** for runtime collection

### Phase 4: Analytics View (Week 4)

1. **Extend `ExecutionRecord`** with `collectibleFragments` array
2. **Create `CollectibleValueEditor`** component
3. **Update `AnalyticsLayout`** to display and edit collectible values
4. **Add persistence** for edited values (localStorage or API)
5. **Add visual indicators** for collected vs defined values
6. **Add E2E tests** for analytics editing workflow

---

## Technical Considerations

### Backward Compatibility

- All changes are **additive** â€” existing workouts continue to work
- `collectionState` defaults to `Defined` for existing fragments
- Parser changes only affect workouts using `?` placeholder

### Performance

- Collection state is a simple enum â€” minimal memory overhead
- Runtime-generated values are collected at block completion â€” no polling
- Analytics updates are batched to reduce re-renders

### Data Integrity

- Collected values include timestamps for audit trail
- Edit history preserved for data recovery
- Runtime-generated values clearly marked as automatic

### Edge Cases

| Scenario | Handling |
|----------|----------|
| `?` without context | Parser error with helpful message |
| Collectible fragment never collected | Display "â€”" in analytics |
| Multiple `?` in same statement | Each creates independent collectible |
| Edit after sync | Conflict resolution via timestamp |

---

## Syntax Reference

### New Syntax Examples

| Syntax | Meaning | Collection Type |
|--------|---------|-----------------|
| `?` | Collect reps | User input |
| `? lb` | Collect weight (lb) | User input |
| `? kg` | Collect weight (kg) | User input |
| `? m` | Collect distance (m) | User input |
| `? rounds` | Collect rounds count | Runtime or user |
| `[:Finish] ?` | Collect elapsed time | Runtime generated |

### Full Workout Examples

```wod
# "Fran" with tracked time
(21-15-9)
  Thrusters 95lb
  Pull-ups
[:Finish] ?  # Total time collected automatically

# Max effort bench press
? lb Bench Press  # User enters weight after

# AMRAP tracking
20:00
  (AMRAP)
    5 Pull-ups
    10 Push-ups
    15 Air Squats
  ? rounds  # Completed rounds collected

# Flexible distance
Run ?m  # User enters actual distance
```

---

## Migration Path

### For Existing Workouts

No changes required. All existing workout definitions continue to work exactly as before.

### For New Features

1. **Monaco Editor**: Add syntax highlighting for `?` placeholder
2. **Typeahead**: Suggest `?` when appropriate
3. **Hover**: Explain collectible fragments on hover
4. **Export**: Include collected values in workout export

---

## Success Criteria

1. âœ… Parser accepts `?` placeholder in place of numbers
2. âœ… Fragments correctly identify collection state
3. âœ… Runtime generates elapsed-time values automatically
4. âœ… Analytics view displays collectible fragments
5. âœ… Users can edit collected values post-workout
6. âœ… All existing tests continue to pass
7. âœ… Documentation updated with new syntax

---

## Open Questions

1. **Should collectible fragments be editable multiple times?**
   - Current design: Yes, with history tracking
   - Alternative: Lock after initial collection

2. **How to handle workout repeats?**
   - Each execution creates new collected values
   - Previous values accessible in history view

3. **Should we support formula-based defaults?**
   - Example: `?+5lb` (last value + 5lb)
   - Defer to future enhancement

4. **Integration with external data sources?**
   - Heart rate from wearables
   - GPS distance from phone
   - Defer to future enhancement

---

## References

- [Metrics Collection](./Metrics_Collection.md)
- [Walkthrough: Metrics & Analytics Collection](./walkthrough-metrics-collection.md)
- [WOD Wiki Syntax Guide](./Wod_Wiki_Syntax.md)
- [Runtime Architecture: Blocks & Strategies](./Runtime_Architecture_Blocks_Strategies.md)
- [Runtime Behaviors Deep Dive](./Runtime_Behaviors_Deep_Dive.md)
