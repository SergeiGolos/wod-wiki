# Workout Timer Notation Parser Documentation

This document describes the process used to parse a custom workout notation language, transforming plain text input into structured `StatementNode` objects, each containing various `StatementFragment` types. This allows for programmatic interpretation of workout instructions.

## Parsing Process Overview

The parsing follows a standard compiler pipeline approach:

1.  **Lexing:** The input string is broken down into a sequence of tokens based on predefined patterns (e.g., numbers, time formats, units, symbols).
2.  **Parsing:** The token sequence is analyzed against a defined grammar to build a Concrete Syntax Tree (CST), representing the hierarchical structure of the input according to the rules.
3.  **Visiting/Interpretation:** The CST is traversed, and an Abstract Syntax Tree (AST) is constructed. In this case, the AST is a list of `StatementNode` objects, where each node represents a line or logical block of the workout and contains typed `StatementFragment` objects holding the specific data (like duration, distance, reps) and source code metadata.

### Flowchart: Overall Process

![[Syntax-Parser-Workflow]]

### Flowchart: Statement Composition (`wodBlock` Rule)

The `wodBlock` rule in the parser defines how different fragments can be combined on a single line or within a block.

![[Syntax-Visitor-Workflow]]

## Statement Structure

The output of the parser is an array of `StatementNode` objects. Each `StatementNode` represents a line or a logical unit within the workout script and contains:

- `id`: A unique identifier, usually derived from the start offset in the source text.
- `fragments`: An array of `StatementFragment` objects parsed from the input for this statement.
- `meta`: `SourceCodeMetadata` detailing the line number, column, and offset in the original input string.
- `children`: An array of IDs of child statements (e.g., lines indented under this one).
- `parent`: The ID of the parent statement, if applicable.
- `next`: The ID of the next statement at the same indentation level, if applicable.
- `isLeaf`: Boolean indicating if the statement is a leaf node in the hierarchy (often determined by `LapFragment`).
- `rounds`: Number of rounds specified, typically derived from a `RoundsFragment`.
## Fragment Breakdown

Fragments represent the individual components of a workout instruction. They are created by the `MdTimerInterpreter` (visitor) based on the CST nodes generated by the `MdTimerParse` (parser).

### Action Fragment

- **Purpose:** Represents a specific action or exercise description, typically enclosed in square brackets.
- **Class:** `ActionFragment`
- **Data:** `action` (string)
- **Parser Rule:** `action`
- **Key Tokens:** `ActionOpen` (`[`), `Collon` (`:`), `Identifier` (e.g., `PushUps`), `AllowedSymbol`, `Minus`, `ActionClose` (`]`)
- **Example Input:** `[:PushUps]`
- **Resulting Fragment:** `ActionFragment { action: 'PushUps' }`

### Distance Fragment

- **Purpose:** Represents a distance measurement.
- **Class:** `DistanceFragment`
- **Data:** `value` (string - numeric part), `units` (string - e.g., 'm', 'km', 'ft')
- **Parser Rule:** `distance`
- **Key Tokens:** `Number` (optional, defaults to '1'), `Distance` (e.g., `m`, `km`, `ft`, `mile`, `miles`)
- **Example Input:** `100m`, `2miles`
- **Resulting Fragments:**
    - `DistanceFragment { value: '100', units: 'm' }`
    - `DistanceFragment { value: '2', units: 'miles' }`
### Effort Fragment

- **Purpose:** Represents a subjective effort level or specific instruction not covered by other fragments. Often used for descriptive text.
- **Class:** `EfortFragment`
- **Data:** `effort` (string)
- **Parser Rule:** `effort`
- **Key Tokens:** `Identifier`, `AllowedSymbol`, `Minus` (consumes sequences of these)
- **Example Input:** `EasyPace`, `MaxEffort!`
- **Resulting Fragments:**
    - `EffortFragment { effort: 'EasyPace' }`
    - `EffortFragment { effort: 'MaxEffort !' }` (Note: Symbols are included)
### Increment Fragment (Trend)

- **Purpose:** Indicates the direction of a timer (count up or count down). Implicitly added as count-down if a `DurationFragment` exists without an explicit trend token.
- **Class:** `IncrementFragment`
- **Data:** `image` (string - the token image, e.g., '^'), `increment` (number: `1` for up, `-1` for down)
- **Parser Rule:** `trend` (explicit), or implicitly added in `wodBlock` visitor logic.
- **Key Tokens:** `Trend` category, specifically `Up` (`^`). Absence implies down when `Timer` token is present.
- **Example Input:** `:30^`, `1:00`
- **Resulting Fragments:**
    - Input `:30^`: `IncrementFragment { image: '^', increment: 1 }` (alongside `TimerFragment`)
    - Input `1:00`: `IncrementFragment { image: '', increment: -1 }` (implicitly added alongside `TimerFragment`)

### Lap Fragment

- **Purpose:** Defines the relationship of a statement to others, controlling grouping and execution flow (e.g., part of a round, a composed set, or a repeated item).
- **Class:** `LapFragment`
- **Data:** `group` (`'round'`, `'compose'`, `'repeat'`), `image` (string - e.g., `-`, `+`)
- **Parser Rule:** `lap`
- **Key Tokens:** `Minus` (`-`), `Plus` (`+`). Can also be implicitly added as `'repeat'` by the visitor based on indentation.
- **Example Input:**
    - `- :30` (Start of a round/set)
    - `:15` (Indented, implies repeat/part of the above)
    - `+ :45` (Composed with the previous item at the same level)
- **Resulting Fragments:**
    - `LapFragment { group: 'round', image: '-' }`
    - `LapFragment { group: 'repeat', image: '' }` (Implicitly added)
    - `LapFragment { group: 'compose', image: '+' }`
### Rep Fragment (Reps)

- **Purpose:** Represents a number of repetitions for an action or within a sequence.
- **Class:** `RepFragment` (Inferred from `timer.visitor.ts` usage)
- **Data:** `reps` (number)
- **Parser Rule:** `reps`, also generated from `sequence` within `rounds`.
- **Key Tokens:** `Number`
- **Example Input:** `10`, `(5-10-15)`
- **Resulting Fragments:**
    - `RepFragment { reps: 10 }`
    - From `(5-10-15)`: `RepFragment { reps: 5 }`, `RepFragment { reps: 10 }`, `RepFragment` { reps: `15 }` (alongside a `RoundsFragment`)

### Resistance Fragment (Weight)

- **Purpose:** Represents a weight or resistance level.
- **Class:** `ResistanceFragment` (Inferred from `timer.visitor.ts` usage)
- **Data:** `value` (string - numeric part), `units` (string - e.g., 'kg', 'lb', 'bw')
- **Parser Rule:** `resistance`
- **Key Tokens:** `AtSign` (`@`, optional), `Number` (optional, defaults to '1'), `Weight` (e.g., `kg`, `lb`, `bw`)
- **Example Input:** `50kg`, `@135lb`, `bw`
- **Resulting Fragments:**
    - `ResistanceFragment { value: '50', units: 'kg' }`
    - `ResistanceFragment { value: '135', units: 'lb' }`
    - `ResistanceFragment { value: '1', units: 'bw' }`

### Rounds Fragment

- **Purpose:** Specifies repetition counts, either as a simple multiplier or a sequence of reps for different rounds. Often associated with grouping parentheses.
- **Class:** `RoundsFragment` (Inferred from `timer.visitor.ts` usage)
- **Data:** `count` (number - either the multiplier or the number of elements in a sequence)
- **Parser Rule:** `rounds` (which uses `sequence`)
- **Key Tokens:** `GroupOpen` (`(`), `GroupClose` (`)`), `Number`, `Minus` (as separator in `sequence`), `Identifier` (for labels, though labels aren't stored in this fragment directly)
- **Example Input:** `:30 (3)`, `(5-10-15)`
- **Resulting Fragments:**
    - Input `:30 (3)`: `RoundsFragment { count: 3 }`
    - Input `(5-10-15)`: `RoundsFragment { count: 3 }` (alongside `RepFragment`s for 5, 10, 15)

### Timer Fragment (Duration)

- **Purpose:** Represents a time duration.
- **Class:** `TimerFragment` (Inferred from `timer.visitor.ts` usage)
- **Data:** `duration` (string - in `D:HH:MM:SS` or `MM:SS` or `:SS` format)
- **Parser Rule:** `duration`
- **Key Tokens:** `Timer` (matches time patterns like `:SS`, `MM:SS`, `HH:MM:SS`, `D:HH:MM:SS`)
- **Example Input:** `:30`, `1:15`, `01:00:00`
- **Resulting Fragments:**
    - `TimerFragment { duration: ':30' }`
    - `TimerFragment { duration: '1:15' }`
    - `TimerFragment { duration: '01:00:00' }`

## Conclusion

This parser leverages the Chevrotain library to define tokens and grammar rules, enabling the transformation of a flexible workout notation into a structured AST. The use of distinct fragments allows for clear separation of concerns and easy interpretation of different