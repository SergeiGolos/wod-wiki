# Feature: Repair System Button Events

## Purpose
Document and repair the system-level event handling for button actions (run, pause, stop, reset) in wod.wiki. Identify where logic is crosswired between the two main event pipelines and propose a robust, SOLID-compliant structure.

## Background
Currently, button events are handled in two places, both following a similar pipeline. This has led to crosswiring and bugs affecting run/pause/stop/reset behaviors.

## Initial Steps
1. Document the two locations handling button events.
2. Map the event pipeline for each button action in both locations.
3. Diagram the flow to visualize logic overlaps or duplications.
4. Summarize findings and highlight areas of concern.

## Findings & Areas of Concern

### Summary of Findings
- Two main locations for button event logic:
  1. **UI Layer** (RunnerControls and related components): Determines visible buttons and dispatches events to the runtime.
  2. **Runtime Layer** (handlers like StartHandler, StopHandler, ResetHandler): Processes events, updates state, and issues actions (e.g., SetButtonAction) to update the UI.

### Key Areas of Concern
- **Duplication of Button State Logic:** Both UI and runtime layers contain logic for active/visible buttons, risking inconsistencies if not kept in sync.
- **Event Pipeline Crosswiring:** UI may allow actions the runtime does not accept, or runtime may ignore/discard events, leading to mismatches and bugs.
- **SOLID Violation Risk:** Mixing UI and runtime state logic can violate the Single Responsibility and Interface Segregation Principles.
- **Difficult Debugging:** Bugs in button behavior are hard to trace to the UI, runtime, or their interaction.

## New Requirements (2025-04-14)

### Stop Events and Pause State
- Stop events must always clear any paused state in the runtime. If the workout is paused and a stop event is received, the runtime should exit the paused state and transition to idle/stopped, ensuring all related state and UI are reset accordingly.

### ButtonRibbon Refactor
- The secondary ButtonRibbon (the one not wired to system run events at start) must render its buttons based on the `buttons[]` property of the current runtime block. This eliminates duplicated button logic and ensures all UI is driven by canonical runtime state.

- Both changes are part of the ongoing effort to centralize button state and event handling according to SOLID principles.

## Event Pipeline Mapping: Run, Pause, Stop, Reset

Below is a step-by-step mapping of how each button action flows through both the UI and runtime layers. This clarifies responsibilities, feedback, and potential crosswiring for each action.

### 1. Run (Start)
- **UI Layer:**
  1. User clicks the "Run" or "Start" button in RunnerControls.
  2. setEvents dispatches a `start` RuntimeEvent.
  3. UI state updates to reflect "running".
- **Runtime Layer:**
  4. StartHandler receives the `start` event.
  5. Handler updates runtime state to "running".
  6. Handler issues SetButtonAction to show "Stop" (and possibly "Complete") buttons.
  7. UI updates visible buttons accordingly (may also update timer display).

### 2. Pause
- **UI Layer:**
  1. User clicks the "Pause" button (if present).
  2. setEvents dispatches a `pause` RuntimeEvent.
  3. UI state updates to reflect "paused".
- **Runtime Layer:**
  4. PauseHandler receives the `pause` event.
  5. Handler updates runtime state to "paused".
  6. Handler issues SetButtonAction to show "Resume" and "Reset" buttons.
  7. UI updates visible buttons accordingly.

### 3. Stop
- **UI Layer:**
  1. User clicks the "Stop" button.
  2. setEvents dispatches a `stop` RuntimeEvent.
  3. UI state updates to reflect "stopped" or "idle".
- **Runtime Layer:**
  4. StopHandler receives the `stop` event.
  5. Handler updates runtime state to "stopped" or "idle".
  6. Handler issues SetButtonAction to show "Resume" and "Reset" buttons (or just "Reset").
  7. UI updates visible buttons accordingly.

### 4. Reset
- **UI Layer:**
  1. User clicks the "Reset" button.
  2. setEvents dispatches a `reset` RuntimeEvent.
  3. UI state updates to reflect "idle".
- **Runtime Layer:**
  4. ResetHandler receives the `reset` event.
  5. Handler resets runtime state and clears results.
  6. Handler issues SetButtonAction to show "Start" button.
  7. UI updates visible buttons accordingly.

---

**Note:**
- At each step, both layers may update button visibility, which is the main source of crosswiring/conflict.
- Any divergence in UI and runtime state logic can result in inconsistent or buggy button behavior.

---

## Event Flow Diagram & Logic Overlaps

Below is a corrected mermaid diagram (no special characters, HTML, or brackets) illustrating the current event flow for button actions Run, Pause, Stop, Reset and where logic is duplicated or crosswired between the UI and runtime layers:

![[2025-04-14.repair-system-button-events 2025-04-14 18.36.33.excalidraw]]
### Explanation
- Both the UI and runtime determine which buttons are shown, creating potential for inconsistent states.
- Dashed arrows: Feedback or circular dependency between UI and runtime button logic.

#### Where Logic Overlaps or Duplicates
- The UI layer (RunnerControls) uses its own state to decide which buttons to display.
- The runtime layer, via SetButtonAction, also dictates button visibility.
- If these two sources of truth diverge, the UI and runtime can become unsynchronized, leading to bugs in button behavior.

## Analysis: Current Runtime State Generation

### How State is Determined
- **runtime.current**: The main reference for the active block in the runtime. Used throughout handlers and actions.
- **Type Checks**: Handlers check `runtime.current.type` for values like "idle", "running", etc. (set by block classes such as IdleRuntimeBlock).
- **Event History**: Some handlers infer state by iterating over `runtime.current.events` and looking for the last "start", "stop", etc. events. This is fragile and can desync if events are missed or out of order.
- **UI State Duplication**: The UI (RunnerControls) maintains its own `state` (idle, running, paused, done) and determines button visibility independently, which can lead to desync.

### Where Logic is Hacky or Duplicated
- **Indirect State Inference**: Handlers infer state by scanning event arrays, not by querying a single source of truth—this is error-prone.
- **Multiple Sources of Truth**: Both runtime and UI maintain their own state and button logic, leading to desync and bugs.
- **Ad-Hoc Type Properties**: Use of `type` on runtime blocks is not always consistent or enforced.
- **Lack of Canonical State API**: No single method/property (e.g., `getState()`) to robustly query state.

### Summary Table

| Location                      | State Source   | Hacky/Duplicated?      |
| ----------------------------- | -------------- | ---------------------- |
| runtime.current.type          | Block property | Ad-hoc, not canonical  |
| runtime.current.events        | Event array    | Fragile, indirect      |
| UI (RunnerControls) state     | UI-managed     | Duplicated, desynced   |
| Button logic in handlers & UI | Both           | Duplicated, crosswired |

### Next Steps
- Design a canonical state API for the runtime block (e.g., `getState()`).
- Refactor all state checks and button logic to use this API as the single source of truth.

## Refactor Plan: Runtime State and Button Logic

### Goal
- Ensure the active runtime block exposes an explicit, queryable state (idle, running, paused, stopped, done).
- Centralize button visibility logic in the runtime, so the UI simply renders what the runtime prescribes.
- Make state transitions and event handling SOLID-compliant and easy to reason about.

### Steps
1. **Analyze Current State Generation**
   - Audit how the runtime currently determines and exposes its state (e.g., via runtime.current, event history, ad-hoc checks).
   - Identify all locations where the UI or runtime infers state using indirect or hacky logic.
2. **Design a Canonical State API**
   - Define a clear, canonical state property or method on the active runtime block (e.g., getState or state).
   - Ensure this state is always up-to-date and reflects the true execution context.
3. **Refactor Runtime Block(s)**
   - Update the runtime block class (and any subclasses) to track and expose its state.
   - Refactor state transitions to update this property explicitly.
   - Remove any redundant or hacky state inference logic.
4. **Centralize Button Logic in Runtime**
   - Move button visibility logic into the runtime (e.g., as a getAvailableButtons method).
   - Ensure the runtime emits a single, authoritative SetButtonAction with the correct buttons for the current state.
   - The UI should only render the buttons prescribed by the runtime—no independent logic.
5. **Update Event Handling Pipeline**
   - Refactor event handlers (StartHandler, StopHandler, etc.) to use the new state API.
   - Ensure all state changes and button updates flow from the runtime, not the UI.
6. **Update UI Integration**
   - Update RunnerControls and related components to consume the runtime’s button set and state, not infer it.
   - Remove UI-side logic that tries to guess or duplicate runtime state.
7. **Testing & Validation**
   - Add tests to verify that state transitions and button updates are correct for all event sequences.
   - Validate that the UI always stays in sync with the runtime state.

### Benefits
- Single source of truth for state and button logic.
- SOLID-compliant: clear separation of concerns, open/closed for extension, easy to test and maintain.
- Eliminates bugs from state desync and logic duplication.

## UI Refactor: RunnerControls Now Uses Canonical State

- `RunnerControls` is now refactored to use `runtime.current?.getState()` as the single source of truth for control button rendering and Chromecast button visibility.
- The `state` prop is removed in favor of directly querying the runtime state, eliminating duplication and ensuring all UI logic is SOLID-compliant and robust.

## Bugfix and Improvements

### 2025-04-14T20:05:34 - Fixed canonical state transition bug

- Updated StartHandler to only trigger StartTimerAction when state is 'idle', ensuring the timer transitions to 'running' and tick events update the display.
- Timer display logic in EditorContainer now always shows timer when a runtime is loaded, regardless of label.
- All handlers and UI now use runtime.current?.getState() as the single source of truth for state.

### Next Steps
- Final verification of event pipeline for all button actions (run/pause/stop/reset)
- Update diagrams and documentation to reflect new canonical state flow

## Worklog
- [ ] [[2025-04-14.repair-system-button-events.kb.md#Backlog]] Tasks are tracked in the Kanban board.

---

## References
- Editor and runtime event/action system
- docs/docs/Components/Editor.md
- docs/docs/Components/Runtime.md
- docs/docs/Components/Compile.md
