# Runtime Data Structures

This document defines the key data structures and interfaces governing the execution engine (runtime) of wod.wiki workouts, primarily defined in `src/core/timer.types.ts`.

## Overview

The runtime system processes a parsed `WodRuntimeScript` using an event-driven model. It manages the overall workout state (`RuntimeState`), executes individual units (`IRuntimeBlock`), handles events (`RuntimeEvent`, `RuntimeBlockHandler`), and produces actions (`IRuntimeAction`) to update the UI and results.

## Core Runtime Interfaces & Classes

### `ITimerRuntime`

This is the central interface representing the timer runtime engine. It manages the overall execution flow and state.

```typescript
export interface ITimerRuntime {  
  // UI Update Callbacks
  setDisplay: (display: TimerDisplayBag) => void;
  setButtons: (buttons: ButtonConfig[]) => void;
  setResults: (results: WodResultBlock[]) => void;
  
  // Control Methods
  reset(): void;
  
  // State Properties
  buttons: ButtonConfig[];
  results: WodResultBlock[];
  display: TimerDisplayBag;
  trace: RuntimeTrace | undefined; // Execution history tracker

  // Execution Internals
  script: RuntimeStack; // Parsed workout script
  current: IRuntimeBlock | undefined; // Currently active block
  
  // Core Methods
  tick(events: RuntimeEvent[]): RuntimeEvent[]; // Processes time/events
  gotoBlock(node: StatementNode | undefined): IRuntimeBlock; // Navigates to a block
}
```

### `IRuntimeBlock`

Represents a discrete, executable unit or state within the workout (e.g., a specific exercise, a rest period, the completed state).

```typescript
export interface IRuntimeBlock {
    type: string;          // Type identifier (e.g., "Exercise", "Rest", "Complete")
    blockId: number;       // Unique ID derived from the StatementNode
    blockKey: string;      // Unique key including execution counts (via StatementKey)
    events : RuntimeEvent[]; // Events that occurred within this block instance
    stack?: StatementNode[]; // StatementNode hierarchy for this block

    // Event processing logic for this block type
    onEvent(event: RuntimeEvent, runtime: ITimerRuntime): IRuntimeAction[];
}
```

### `RuntimeState`

Holds high-level status information about the runtime.

```typescript
export interface RuntimeState {
    isRunning: boolean;
    isPaused: boolean;
    isComplete: boolean;
    currentBlockId?: number; // ID of the currently active StatementNode
    elapsedTime: number;      // Total elapsed time in milliseconds
    remainingTime?: number;    // Total remaining time (if applicable)
}
```

### `IRuntimeAction`

Interface for actions generated by `IRuntimeBlock` or `RuntimeBlockHandler` instances in response to events. These actions trigger updates in the UI or runtime state.

```typescript
export interface IRuntimeAction {
    // Applies the action to the runtime, potentially triggering UI updates
    // and returning further events.
    apply(runtime: ITimerRuntime): RuntimeEvent[];
}
```

Common actions include `DisplayUpdateAction`, `SetButtonAction`, `SetResultAction`, etc.

### `RuntimeEvent`

Represents significant occurrences during workout execution (e.g., timer tick, user interaction, block completion).

```typescript
export interface RuntimeEvent {
    timestamp: Date;    // When the event occurred
    name: string;       // Type of event (e.g., "TickEvent", "StartEvent", "CompleteEvent")
    // Additional event-specific properties may exist
}
```

### `RuntimeBlockHandler`

Defines a function signature for handling specific `RuntimeEvent` types, often used within `IRuntimeBlock` implementations.

```typescript
export type RuntimeBlockHandler = {
    apply: (event: RuntimeEvent, runtime: ITimerRuntime) => IRuntimeAction[];
};
```

### `WodRuntimeScript`

The result of parsing the workout definition text. Contains the source and the tree of statements.

```typescript
export type WodRuntimeScript = {
    source: string;           // Original workout text
    statements: StatementNode[]; // Root nodes of the parsed statement tree
};
```
(See `Statement Block.md` for `StatementNode` details)

### `RuntimeTrace` & `StatementKey`

Internal mechanisms used by `ITimerRuntime` and `IRuntimeBlock` to track the execution path and generate unique keys (`blockKey`) for repeated blocks/statements.

- `StatementKey`: Represents a specific instance of a statement execution path (e.g., Round 2, Item 3).
- `RuntimeTrace`: Manages the history of `StatementKey`s and execution counts for each `StatementNode`.

## Event Processing Flow

The general flow is:

1.  An external trigger (timer tick, user input) creates a `RuntimeEvent`.
2.  The `ITimerRuntime.tick()` method processes the event.
3.  `tick()` may delegate the event to the `current` `IRuntimeBlock.onEvent()` method (or a specific `RuntimeBlockHandler`).
4.  The handler processes the `RuntimeEvent` based on the block's state and type.
5.  The handler returns an array of `IRuntimeAction` objects.
6.  `tick()` calls `apply()` on each `IRuntimeAction`, which updates the UI (via `setDisplay`, `setButtons`, `setResults`) and potentially generates new `RuntimeEvent`s.
7.  The `ITimerRuntime` may transition to a new `IRuntimeBlock` via `gotoBlock()` based on actions or internal logic.

```ascii
┌──────────────┐      ┌───────────────┐      ┌────────────────┐      ┌─────────────────┐      ┌──────────┐
│ RuntimeEvent ├─►│ ITimerRuntime ├─►│ IRuntimeBlock  ├─►│ IRuntimeAction[]├─►│ UI Update│
│ (e.g., Tick) │      │   .tick()     │      │   .onEvent()   │      │  (e.g., Apply)  │      └──────────┘
└──────────────┘      └───────────────┘      └────────────────┘      └─────────────────┘
```

This structure allows for modular and testable runtime logic, where different block types encapsulate specific workout behaviors.
