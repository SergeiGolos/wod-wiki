{
  "nodes": [
    {
      "id": "title",
      "type": "text",
      "x": 300,
      "y": -300,
      "width": 500,
      "height": 80,
      "text": "# Execution Cycle Deep Dive\n\n**How actions build stacks and get processed**",
      "color": "6"
    },
    {
      "id": "grp_trigger",
      "type": "group",
      "x": -150,
      "y": -180,
      "width": 400,
      "height": 500,
      "label": "1. TRIGGER",
      "color": "5"
    },
    {
      "id": "trigger_start",
      "type": "text",
      "x": -100,
      "y": -130,
      "width": 300,
      "height": 120,
      "text": "## Workout Start\n\n**RuntimeFactory.createRuntime()**\n\n1. Create WodScript from WodBlock\n2. Instantiate ScriptRuntime\n3. Build root block via strategy",
      "color": "5"
    },
    {
      "id": "trigger_root",
      "type": "text",
      "x": -100,
      "y": 30,
      "width": 300,
      "height": 140,
      "text": "## WorkoutRootStrategy.build()\n\n**Creates Root Block with:**\n- `ChildIteratorBehavior` (child queue)\n- `RoundInitBehavior` (round tracking)\n- `RoundCompletionBehavior`\n- `PopOnNextBehavior`",
      "color": "5"
    },
    {
      "id": "trigger_push",
      "type": "text",
      "x": -100,
      "y": 210,
      "width": 300,
      "height": 100,
      "text": "## Initial Push\n\n`runtime.pushBlock(rootBlock)`\n\n→ Triggers **mount()** lifecycle",
      "color": "3"
    },
    {
      "id": "grp_mount",
      "type": "group",
      "x": 300,
      "y": -180,
      "width": 450,
      "height": 500,
      "label": "2. MOUNT LIFECYCLE",
      "color": "4"
    },
    {
      "id": "mount_push",
      "type": "text",
      "x": 350,
      "y": -130,
      "width": 350,
      "height": 160,
      "text": "## pushBlock() Flow\n\n1. `onBeforePush` hook\n2. Set `startTime` on block\n3. `stack.push(block)` → notify subscribers\n4. Dispatch `StackPushEvent`\n5. **Call `block.mount(runtime)`**\n6. `queueActions(mountActions)`",
      "color": "4"
    },
    {
      "id": "mount_block",
      "type": "text",
      "x": 350,
      "y": 70,
      "width": 350,
      "height": 180,
      "text": "## RuntimeBlock.mount()\n\n1. Create `BehaviorContext` with:\n   - `block`, `clock`, `stackLevel`, `runtime`\n2. Register default 'next' event handler\n3. **For each behavior:**\n   - Call `behavior.onMount(ctx)`\n   - Collect returned actions\n4. Return `IRuntimeAction[]`",
      "color": "4"
    },
    {
      "id": "mount_behavior",
      "type": "text",
      "x": 350,
      "y": 290,
      "width": 350,
      "height": 180,
      "text": "## Behavior.onMount(ctx)\n\n**ChildIteratorBehavior:**\n→ `CompileAndPushBlockAction(firstChildIds)`\n\n**TimerBehavior:**\n→ Subscribe to 'tick' events\n→ Initialize timer memory\n\n**RoundBehavior:**\n→ Set `round = 1` in memory",
      "color": "3"
    },
    {
      "id": "grp_process",
      "type": "group",
      "x": 800,
      "y": -180,
      "width": 450,
      "height": 700,
      "label": "3. ACTION PROCESSING",
      "color": "1"
    },
    {
      "id": "process_queue",
      "type": "text",
      "x": 850,
      "y": -130,
      "width": 350,
      "height": 140,
      "text": "## queueActions(actions[])\n\n1. Push actions to `_actionQueue`\n2. Call `processActions()`\n3. Guard: If already processing, exit\n   (actions will be processed in current loop)",
      "color": "1"
    },
    {
      "id": "process_loop",
      "type": "text",
      "x": 850,
      "y": 50,
      "width": 350,
      "height": 200,
      "text": "## processActions() Loop\n\n```\ndo {\n  while (queue.length > 0) {\n    action = queue.shift()\n    action.do(runtime) // May add more!\n  }\n  \n  sweepCompletedBlocks()\n  \n} while (queue.length > 0)\n```",
      "color": "1"
    },
    {
      "id": "process_compile",
      "type": "text",
      "x": 850,
      "y": 290,
      "width": 350,
      "height": 160,
      "text": "## CompileAndPushBlockAction.do()\n\n1. Resolve IDs → `ICodeStatement[]`\n2. `jit.compile(statements, runtime)`\n   - Match strategies\n   - Build via `BlockBuilder`\n3. Create `PushBlockAction(block)`\n4. Execute push → **Recursive!**",
      "color": "2"
    },
    {
      "id": "process_sweep",
      "type": "text",
      "x": 850,
      "y": 490,
      "width": 350,
      "height": 180,
      "text": "## sweepCompletedBlocks()\n\n**Auto-cleanup completed blocks:**\n\n```\nwhile (stack.current?.isComplete) {\n  popBlock() // Handles:\n  // 1. unmount()\n  // 2. parent.next()\n  // 3. May queue more actions\n}\n```",
      "color": "1"
    },
    {
      "id": "grp_next",
      "type": "group",
      "x": -150,
      "y": 370,
      "width": 400,
      "height": 400,
      "label": "4. NEXT & COMPLETION",
      "color": "3"
    },
    {
      "id": "next_trigger",
      "type": "text",
      "x": -100,
      "y": 420,
      "width": 300,
      "height": 140,
      "text": "## Completion Triggers\n\n1. **Timer expires** → `markComplete()`\n2. **Loop exhausted** → `markComplete()`\n3. **Child popped** → `parent.next()` called\n4. **User action** → NextEvent dispatched",
      "color": "3"
    },
    {
      "id": "next_flow",
      "type": "text",
      "x": -100,
      "y": 600,
      "width": 300,
      "height": 140,
      "text": "## RuntimeBlock.next()\n\n1. For each behavior:\n   - Call `behavior.onNext(ctx)`\n   - **ChildIterator** → push next child\n   - **Loop** → increment & check\n2. Return `IRuntimeAction[]`",
      "color": "3"
    },
    {
      "id": "grp_pop",
      "type": "group",
      "x": 300,
      "y": 370,
      "width": 450,
      "height": 400,
      "label": "5. UNMOUNT LIFECYCLE",
      "color": "2"
    },
    {
      "id": "pop_flow",
      "type": "text",
      "x": 350,
      "y": 420,
      "width": 350,
      "height": 300,
      "text": "## popBlock() Flow\n\n1. Capture `stackLevel` before pop\n2. Create `SnapshotClock` at completion\n3. **Call `block.unmount(runtime)`**\n4. `stack.pop()` → notify subscribers\n5. Dispatch `StackPopEvent`\n6. Execute unmount actions **immediately**\n7. `block.dispose()` + cleanup\n8. **Call `parent.next(runtime)`** ← key!\n9. `emitOutputStatement(block, level)`",
      "color": "2"
    },
    {
      "id": "grp_output",
      "type": "group",
      "x": 800,
      "y": 560,
      "width": 450,
      "height": 250,
      "label": "6. OUTPUT EMISSION",
      "color": "4"
    },
    {
      "id": "output_emit",
      "type": "text",
      "x": 850,
      "y": 610,
      "width": 350,
      "height": 180,
      "text": "## emitOutputStatement()\n\n**Called during popBlock:**\n\n1. Build `TimeSpan(startTime, endTime)`\n2. Collect `fragments[]` from block\n3. Create `OutputStatement`\n4. `addOutput(output)`\n5. Notify all subscribers",
      "color": "4"
    },
    {
      "id": "note_recursion",
      "type": "text",
      "x": -150,
      "y": 820,
      "width": 700,
      "height": 100,
      "text": "## ⟲ Recursive Loop\n\n**popBlock() → parent.next() → queueActions() → processActions() → sweepCompleted() → popBlock()...**\n\nThis continues until `stack.count === 0` (workout complete)",
      "color": "6"
    }
  ],
  "edges": [
    {
      "id": "edge_start_to_root",
      "fromNode": "trigger_start",
      "fromSide": "bottom",
      "toNode": "trigger_root",
      "toSide": "top",
      "color": "5"
    },
    {
      "id": "edge_root_to_push",
      "fromNode": "trigger_root",
      "fromSide": "bottom",
      "toNode": "trigger_push",
      "toSide": "top",
      "color": "5"
    },
    {
      "id": "edge_push_to_mount",
      "fromNode": "trigger_push",
      "fromSide": "right",
      "toNode": "mount_push",
      "toSide": "left",
      "label": "pushBlock()",
      "color": "4"
    },
    {
      "id": "edge_mount1_to_2",
      "fromNode": "mount_push",
      "fromSide": "bottom",
      "toNode": "mount_block",
      "toSide": "top",
      "color": "4"
    },
    {
      "id": "edge_mount2_to_3",
      "fromNode": "mount_block",
      "fromSide": "bottom",
      "toNode": "mount_behavior",
      "toSide": "top",
      "color": "4"
    },
    {
      "id": "edge_behavior_to_queue",
      "fromNode": "mount_behavior",
      "fromSide": "right",
      "toNode": "process_queue",
      "toSide": "left",
      "label": "actions[]",
      "color": "1"
    },
    {
      "id": "edge_queue_to_loop",
      "fromNode": "process_queue",
      "fromSide": "bottom",
      "toNode": "process_loop",
      "toSide": "top",
      "color": "1"
    },
    {
      "id": "edge_loop_to_compile",
      "fromNode": "process_loop",
      "fromSide": "bottom",
      "toNode": "process_compile",
      "toSide": "top",
      "label": "action.do()",
      "color": "1"
    },
    {
      "id": "edge_compile_to_mount",
      "fromNode": "process_compile",
      "fromSide": "left",
      "toNode": "mount_push",
      "toSide": "right",
      "label": "⟲ recursive push",
      "color": "2"
    },
    {
      "id": "edge_loop_to_sweep",
      "fromNode": "process_loop",
      "fromSide": "bottom",
      "toNode": "process_sweep",
      "toSide": "top",
      "color": "1"
    },
    {
      "id": "edge_sweep_to_pop",
      "fromNode": "process_sweep",
      "fromSide": "left",
      "toNode": "pop_flow",
      "toSide": "right",
      "label": "popBlock()",
      "color": "2"
    },
    {
      "id": "edge_pop_to_next",
      "fromNode": "pop_flow",
      "fromSide": "left",
      "toNode": "next_flow",
      "toSide": "right",
      "label": "parent.next()",
      "color": "3"
    },
    {
      "id": "edge_next_to_queue",
      "fromNode": "next_flow",
      "fromSide": "top",
      "toNode": "process_queue",
      "toSide": "bottom",
      "label": "queueActions()",
      "color": "1"
    },
    {
      "id": "edge_pop_to_output",
      "fromNode": "pop_flow",
      "fromSide": "bottom",
      "toNode": "output_emit",
      "toSide": "top",
      "label": "emit output",
      "color": "4"
    }
  ]
}
