import { IRuntimeBlockStrategy } from '../../../contracts/IRuntimeBlockStrategy';
import { IRuntimeBlock } from '../../../contracts/IRuntimeBlock';
import { IScriptRuntime } from '../../../contracts/IScriptRuntime';
import { ICodeStatement } from '../../../../core/models/CodeStatement';
import { BlockBuilder } from '../../BlockBuilder';
import { RestBlock, RestBlockConfig } from '../../../blocks/RestBlock';

/**
 * RestBlockStrategy composes RestBlocks for rest periods between exercises.
 *
 * This is a direct-build strategy (match() returns false) — it is not
 * discovered by the JIT pipeline. Instead, RestBlocks are auto-generated
 * at runtime by RestBlockBehavior when a parent's countdown timer has
 * remaining time after all child exercises complete.
 *
 * ## Responsibilities
 *
 * 1. Accept REST duration from parent block (remaining interval time
 *    or configured rest duration)
 * 2. Create a RestBlock with countdown timer set to the given duration
 * 3. Ensure proper behavior composition:
 *    - SegmentOutputBehavior (emit "Rest" segment)
 *    - TimerInitBehavior (countdown timer)
 *    - TimerTickBehavior (drive countdown)
 *    - TimerCompletionBehavior (auto-complete when timer expires)
 *    - DisplayInitBehavior (show rest countdown display)
 *    - SoundCueBehavior (rest-over beep + countdown beeps)
 *
 * ## Usage Patterns
 *
 * ### Auto-generated by RestBlockBehavior (primary)
 * AMRAP and EMOM parent blocks have RestBlockBehavior in their behavior
 * chain. When exercises complete before the interval timer expires,
 * RestBlockBehavior creates PushRestBlockAction which uses RestBlock
 * directly.
 *
 * ### Explicit rest in workout script (future)
 * When the parser encounters an explicit rest statement (e.g., "Rest 2:00"),
 * this strategy could match and compile it. Currently, this path is not
 * used — rest is always auto-generated.
 *
 * @see RestBlock
 * @see RestBlockBehavior
 */
export class RestBlockStrategy implements IRuntimeBlockStrategy {
    priority = 50;

    /**
     * Rest blocks are currently auto-generated, not parsed from statements.
     * Returns false — RestBlocks are created directly via build().
     */
    match(_statements: ICodeStatement[], _runtime: IScriptRuntime): boolean {
        return false;
    }

    /**
     * Composable apply — not used for rest blocks.
     */
    apply(_builder: BlockBuilder, _statements: ICodeStatement[], _runtime: IScriptRuntime): void {
        // No-op for direct build
    }

    /**
     * Builds a RestBlock with the specified configuration.
     *
     * @param runtime - The script runtime context
     * @param config - Rest block configuration with duration and optional label
     * @returns A fully composed RestBlock
     * @throws {RangeError} If durationMs is negative
     *
     * @example
     * ```typescript
     * const strategy = new RestBlockStrategy();
     * const rest = strategy.build(runtime, {
     *     durationMs: 30000,  // 30 seconds
     *     label: 'Rest'
     * });
     * ```
     */
    build(runtime: IScriptRuntime, config: RestBlockConfig): IRuntimeBlock {
        return new RestBlock(runtime, config);
    }

    /**
     * Builds a RestBlock with just a duration (convenience method).
     *
     * @param runtime - The script runtime context
     * @param durationMs - Rest duration in milliseconds
     * @param label - Optional label (default: "Rest")
     * @returns A fully composed RestBlock
     * @throws {RangeError} If durationMs is negative
     */
    buildWithDuration(
        runtime: IScriptRuntime,
        durationMs: number,
        label?: string
    ): IRuntimeBlock {
        return this.build(runtime, {
            durationMs,
            label
        });
    }
}

/**
 * Default instance for convenience.
 */
export const restBlockStrategy = new RestBlockStrategy();
