import { 
  IRuntimeAction, 
  IRuntimeBlock, 
  IRuntimeEvent, 
  ITimerRuntime,
  ITimeSpan,
  PrecompiledNode
} from "@/core/timer.types";
import { EventHandler } from "../EventHandler";
import { BlockContext } from "./BlockContext";

/**
 * Abstract base class that implements the Template Method pattern for runtime blocks.
 * This class provides the basic structure for all blocks and handles common behaviors
 * like logging while allowing concrete subclasses to define specific behaviors.
 */
export abstract class AbstractBlockLifecycle implements IRuntimeBlock {
  constructor(
    // meta
    protected sources: PrecompiledNode[]
  ) {
    this.blockId = sources.map(s => s.id).join(":") || "";
    
    // Initialize the BlockContext with defalt values
    this.ctx = new BlockContext({
      // Default empty values that will be populated in lifecycle methods
      runtime: {} as ITimerRuntime,
      index: 0,
      spans: []
    });
  }
  
  public blockKey?: string | undefined;
  // meta
  public parent?: IRuntimeBlock | undefined;    
  public blockId: string;
  
  // Block state context - holds all mutable state
  protected ctx: BlockContext;
  
  // Runtime event handlers
  protected handlers: EventHandler[] = [];  
  
  // Getters for encapsulated properties
  public getSources(): PrecompiledNode[] {
    return this.sources;
  }
  
  public getIndex(): number {
    return this.ctx.index;
  }
  
  public getSpans(): ITimeSpan[] {
    return this.ctx.spans;
  }
  
  /**
   * Returns the block's context - useful for testing and state management
   */
  public getContext(): BlockContext {
    return this.ctx;
  }
  
  /**
   * Template method for enter lifecycle phase
   * This follows the template method pattern - the base method handles
   * common behavior while abstract methods are implemented by subclasses
   */
  public enter(runtime: ITimerRuntime): IRuntimeAction[] {
    console.log(`+=== enter : ${this.blockKey}`);
    
    // Update the context with the current runtime
    this.ctx.runtime = runtime;
    
    // Call the hook method for specific behavior
    return this.doEnter(runtime);
  }
  
  /**
   * Template method for next lifecycle phase
   * Handles common behavior and delegates specific behavior to doNext
   */
  public next(runtime: ITimerRuntime): IRuntimeAction[] {
    console.log(`+=== next : ${this.blockKey}`);
    
    // Update the context with the current runtime
    this.ctx.runtime = runtime;
    
    // Call the hook method for specific behavior
    return this.doNext(runtime);
  }
  
  /**
   * Template method for leave lifecycle phase
   * Handles common behavior and delegates specific behavior to doLeave
   */
  public leave(runtime: ITimerRuntime): IRuntimeAction[] {
    console.log(`+=== leave : ${this.blockKey}`);
    
    // Update the context with the current runtime
    this.ctx.runtime = runtime;
    
    // Call the hook method for specific behavior
    return this.doLeave(runtime);
  }
  
  /**
   * Event handling method
   */
  public handle(
    runtime: ITimerRuntime,
    event: IRuntimeEvent,
    system: EventHandler[]
  ): IRuntimeAction[] {
    console.log(`+=== handle : ${this.blockKey}`);
    
    // Update the context with the current runtime
    this.ctx.runtime = runtime;
    
    const result: IRuntimeAction[] = [];
    
    // Process the event with block-specific handlers
    for (const handler of this.handlers) {
      const actions = handler.apply(event, runtime);
      result.push(...actions);
    }
    
    // If no actions generated by block handlers, try system handlers
    if (result.length === 0) {
      for (const handler of system) {
        const actions = handler.apply(event, runtime);
        result.push(...actions);
      }
    }
    
    return result;
  }
  
  /**
   * Helper method to retrieve data from the source nodes
   */
  public get<T>(fn: (node: PrecompiledNode) => T[], recursive?: boolean): T[] {
    let block: IRuntimeBlock = this;
    let result: T[] = block.getSources().flatMap(fn) ?? [];
    while (recursive && block.parent) {
      block = block.parent;
      result.push(...block.getSources().flatMap(fn) ?? []);
    }
    
    return result;
  }
  
  // Abstract hook methods
  /**
   * Hook method for enter - subclasses must implement
   * Implementation should use this.ctx for state management
   */
  protected abstract doEnter(runtime: ITimerRuntime): IRuntimeAction[];
  
  /**
   * Hook method for next - subclasses must implement
   * Implementation should use this.ctx for state management
   */
  protected abstract doNext(runtime: ITimerRuntime): IRuntimeAction[];
  
  /**
   * Hook method for leave - subclasses must implement
   * Implementation should use this.ctx for state management
   */
  protected abstract doLeave(runtime: ITimerRuntime): IRuntimeAction[];
}
