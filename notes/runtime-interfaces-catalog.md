# Runtime Interfaces Catalog

**Document Purpose**: Complete catalog of all runtime interface methods, their inputs, and return types.  
**Last Updated**: 2025-10-11  
**Status**: Reference document for planned refactoring

---

## Table of Contents

1. [IRuntimeBehavior](#iruntimebehavior)
2. [IRuntimeAction](#iruntimeaction)
3. [IRuntimeBlock](#iruntimeblock)
4. [IScriptRuntime](#iscriptruntime)
5. [IRuntimeMemory](#iruntimememory)
6. [IBlockContext](#iblockcontext)
7. [IMemoryReference](#imemoryreference)
8. [TypedMemoryReference](#typedmemoryreference)
9. [IEvent](#ievent)
10. [IEventHandler](#ieventhandler)
11. [IRuntimeBlockStrategy](#iruntimeblockstrategy)
12. [IStackValidator](#istackvalidator)
13. [Supporting Types](#supporting-types)

---

## IRuntimeBehavior

**File**: `src/runtime/IRuntimeBehavior.ts`  
**Purpose**: Generic, composable behavior contract applied to runtime blocks

### Methods

#### onPush
```typescript
onPush?(runtime: IScriptRuntime, block: IRuntimeBlock): IRuntimeAction[]
```
**Purpose**: Called when the owning block is pushed onto the stack  
**Parameters**:
- `runtime: IScriptRuntime` - The script runtime context
- `block: IRuntimeBlock` - The block instance being pushed

**Returns**: `IRuntimeAction[]` - Array of initial events/actions to emit  
**Optional**: Yes  
**Notes**: May return initial events to emit

#### onNext
```typescript
onNext?(runtime: IScriptRuntime, block: IRuntimeBlock): IRuntimeAction[]
```
**Purpose**: Called when determining the next block after a child completes  
**Parameters**:
- `runtime: IScriptRuntime` - The script runtime context
- `block: IRuntimeBlock` - The block instance determining next steps

**Returns**: `IRuntimeAction[]` - Array of actions representing next block(s) or completion  
**Optional**: Yes  
**Notes**: Return a block to override default next behavior

#### onPop
```typescript
onPop?(runtime: IScriptRuntime, block: IRuntimeBlock): IRuntimeAction[]
```
**Purpose**: Called right before the owning block is popped from the stack  
**Parameters**:
- `runtime: IScriptRuntime` - The script runtime context
- `block: IRuntimeBlock` - The block instance being popped

**Returns**: `IRuntimeAction[]` - Array of cleanup/final actions to execute  
**Optional**: Yes  
**Notes**: Final cleanup before block removal

---

## IRuntimeAction

**File**: `src/runtime/IRuntimeAction.ts`  
**Purpose**: Interface for actions that can be performed by the runtime in response to events

### Properties

- `type: string` - Type of action to perform

### Methods

#### do
```typescript
do(runtime: IScriptRuntime): void
```
**Purpose**: Executes the action within the given runtime context  
**Parameters**:
- `runtime: IScriptRuntime` - The script runtime context

**Returns**: `void`  
**Notes**: Side effects include runtime state changes

---

## IRuntimeBlock

**File**: `src/runtime/IRuntimeBlock.ts`  
**Purpose**: Represents a runtime block that can be executed within the WOD runtime stack

### Properties 

// TODO: update the properties to match.

- `readonly context: IBlockContext` - the block context generated by the jit when creating the new block.
- `readonly key: BlockKey` - Unique identifier for this block instance
- `readonly sourceIds: number[]` - Source code `CodeStatement` identifiers that are used to build this runtime block
- `readonly behaviors: IRuntimeBehavior[]` - the collection of behaviors that define the runtime block being created.

### Methods

#### push
```typescript
push(runtime: IScriptRuntime): IRuntimeAction[]    // TODO: Rename to mount and upadte signature
```
**Purpose**: Called when this block is pushed onto the runtime stack  
**Parameters**: None  
**Returns**: `IRuntimeAction[]` - Array of runtime actions to execute after push  
**Performance**: Should complete within 50ms  
**Notes**: Sets up initial state and registers event listeners. In constructor-based initialization pattern, this handles runtime registration only.

#### next
```typescript
next(runtime: IScriptRuntime): IRuntimeAction[] // TODO: update signature.
```
**Purpose**: Called when a child block completes execution  
**Parameters**: None  
**Returns**: `IRuntimeAction[]` - Array of runtime actions representing next execution steps  
**Performance**: Should complete within 50ms  
**Notes**: Determines the next block(s) to execute or signals completion

#### pop
```typescript
pop(runtime: IScriptRuntime): IRuntimeAction[]  // TODO: Existing functionality moves to dispose
```
**Purpose**: Called when this block is popped from the runtime stack  
**Parameters**: None  
**Returns**: `IRuntimeAction[]` - Array of runtime actions to execute after pop  
**Performance**: Should complete within 50ms  
**Notes**: Handles completion logic and manages result spans. In consumer-managed disposal pattern, this method does NOT clean up resources.

#### dispose
```typescript
dispose(runtime: IScriptRuntime): IRuntimeAction[]  // TODO: Part of the old pop function.  the activities described in this interface shoudl be done with aditional actions, identify the unique elemnts of the actions and create actions based on them as an addendum on this document for addtional types that need to be created. 
```
**Purpose**: Cleans up any resources held by this block  
**Parameters**: None  
**Returns**: `void`  
**Performance**: MUST complete within 50ms  
**Critical Requirements**:
- MUST be called by consumer after popping from stack
- Must handle being called multiple times safely
- Should not throw exceptions during cleanup
- Close file handles, network connections
- Unregister event listeners and callbacks
- Release memory references and clear caches
- Dispose of child objects and dependencies

**Throws**: Never - Should handle all cleanup errors internally

---

## IScriptRuntime

**File**: `src/runtime/IScriptRuntime.ts`  
**Purpose**: Main runtime interface coordinating script execution

### Properties

- `readonly script: WodScript` - The workout script being executed
- `readonly memory: IRuntimeMemory` - Runtime memory manager
- `readonly stack: RuntimeStack` - Runtime execution stack
- `readonly jit: JitCompiler` - JIT compiler instance

### Methods

#### handle
```typescript
handle(event: IEvent): void
```
**Purpose**: Handles runtime events  
**Parameters**:
- `event: IEvent` - The event to handle

**Returns**: `void`  
**Notes**: Central event handling mechanism

---

## IRuntimeMemory

**File**: `src/runtime/IRuntimeMemory.ts`  
**Purpose**: Manages separate memory from the execution stack for debugging and state inspection

### Type Definitions

```typescript
type Nullable<T> = { [K in keyof T]: T[K] | null }
```

### Methods

#### allocate
```typescript
allocate<T>(
  type: string, 
  ownerId: string, 
  initialValue?: T, 
  visibility?: 'public' | 'private'
): TypedMemoryReference<T>
```
**Purpose**: Allocates a new memory location and returns a reference to it  
**Parameters**:
- `type: string` - Memory type identifier (e.g., 'timer-time-spans')
- `ownerId: string` - Unique identifier of the owning block
- `initialValue?: T` - Optional initial value for the memory (generic type)
- `visibility?: 'public' | 'private'` - Access visibility ('public' for cross-block, 'private' for internal)

**Returns**: `TypedMemoryReference<T>` - Typed reference for accessing allocated memory  
**Notes**: Memory will be automatically cleaned up when the associated stack item is removed

#### get
```typescript
get<T>(reference: TypedMemoryReference<T>): T | undefined
```
**Purpose**: Gets the value of a memory reference  
**Parameters**:
- `reference: TypedMemoryReference<T>` - The memory reference to read

**Returns**: `T | undefined` - The value or undefined if reference doesn't exist or was cleaned up  
**Notes**: Returns undefined if the reference doesn't exist or has been cleaned up

#### set
```typescript
set<T>(reference: TypedMemoryReference<T>, value: T): void
```
**Purpose**: Sets the value of a memory reference  
**Parameters**:
- `reference: TypedMemoryReference<T>` - The memory reference to update
- `value: T` - The new value to set

**Returns**: `void`  
**Throws**: Error if the reference is invalid

#### search
```typescript
search(criteria: Nullable<IMemoryReference>): IMemoryReference[]
```
**Purpose**: Searches for memory references that match the given criteria  
**Parameters**:
- `criteria: Nullable<IMemoryReference>` - Search criteria object (any non-null fields are matched)

**Returns**: `IMemoryReference[]` - Array of matching references (empty if none found)  
**Notes**: The search is based on any non-null fields in the criteria object

#### release
```typescript
release(reference: IMemoryReference): void
```
**Purpose**: Manually releases a memory reference and all its children  
**Parameters**:
- `reference: IMemoryReference` - The reference to release

**Returns**: `void`  
**Notes**: This is automatically called when stack items are removed

---

## IBlockContext

**File**: `src/runtime/IBlockContext.ts`  
**Purpose**: Provides memory allocation and access for a runtime block

### Properties

- `readonly ownerId: string` - Unique identifier for the owning block
- `readonly references: ReadonlyArray<IMemoryReference>` - All memory references allocated by this context

### Methods

#### allocate
```typescript
allocate<T>(
  type: MemoryTypeEnum,  // to be defined (TimeSpan / Metrics / ) 
  initialValue?: T, 
  visibility?: 'public' | 'private'
): TypedMemoryReference<T>
```
**Purpose**: Allocate memory for this block's state  
**Parameters**:
- `type: string` - Memory type identifier (e.g., 'timer-time-spans')
- `initialValue?: T` - Optional initial value for the memory
- `visibility?: 'public' | 'private'` - 'public' for cross-block access, 'private' for internal use

**Returns**: `TypedMemoryReference<T>` - Typed memory reference for accessing the allocated memory  and internally stores the references to clean up later.

**Throws**: Error if context has been released

#### get
```typescript
get<T>(type: string): TypedMemoryReference<T> | undefined
```
**Purpose**: Get the first memory reference of a specific type  
**Parameters**:
- `type: string` - Memory type identifier to search for

**Returns**: `TypedMemoryReference<T> | undefined` - Memory reference or undefined if not found

#### getAll
```typescript
getAll<T>(type: string): TypedMemoryReference<T>[]
```
**Purpose**: Get all memory references of a specific type  
**Parameters**:
- `type: string` - Memory type identifier to search for

**Returns**: `TypedMemoryReference<T>[]` - Array of matching memory references (empty if none found)  
**Notes**: Useful when multiple memory entries of the same type exist

#### release
```typescript
release(): void
```
**Purpose**: Release all allocated memory references  
**Parameters**: None  
**Returns**: `void`  
**Notes**: 
- Must be called by consumer after block disposal
- This method is idempotent - calling multiple times is safe
- After release, allocate() will throw an error

#### isReleased  

```typescript
isReleased(): boolean  // TODO remove not needed.
```
**Purpose**: Check if this context has been released  
**Parameters**: None  
**Returns**: `boolean` - true if release() has been called

---

## IMemoryReference

**File**: `src/runtime/IMemoryReference.ts`  
**Purpose**: A reference to a memory location that can be passed between components

### Properties

- `readonly id: string` - Unique identifier for this memory reference
- `readonly ownerId: string` - Identifier of the block that owns this memory
- `readonly type: string` - Memory type identifier
- `readonly visibility: 'public' | 'private'` - Access visibility level
- `value(): any?`  // TODO this should return the untyped version of the object it the memory location is not empty.
- `subscription: IMemorySubscription[]`
### Notes
This is a data-only interface with no methods. See TypedMemoryReference for the active implementation.

---

## TypedMemoryReference\<T>

**File**: `src/runtime/IMemoryReference.ts`  
**Purpose**: Typed implementation of IMemoryReference with subscription capabilities

### Properties

- `readonly id: string` - Auto-generated UUID for this reference
- `readonly ownerId: string` - Identifier of the owning block
- `readonly type: string` - Memory type identifier
- `visibility: 'public' | 'private'` - Access visibility level

### Methods

#### get
```typescript
get(): T | undefined
```
**Purpose**: Gets the current value from memory  
**Parameters**: None  
**Returns**: `T | undefined` - The current value or undefined if not found

#### set
```typescript
set(value: T): void
```
**Purpose**: Sets the value in memory  
**Parameters**:
- `value: T` - The new value to set

**Returns**: `void`

#### subscribe
```typescript
subscribe(
  callback: (newValue: T | undefined, oldValue: T | undefined) => void,
  options?: SubscriptionOptions
): () => void
```
**Purpose**: Subscribe to changes in this memory reference  
**Parameters**:
- `callback: (newValue: T | undefined, oldValue: T | undefined) => void` - Function to call when value changes
- `options?: SubscriptionOptions` - Subscription options
  - `immediate?: boolean` - Call callback immediately with current value
  - `throttle?: number` - Min milliseconds between notifications

**Returns**: `() => void` - Unsubscribe function  
**Notes**: Callback is invoked whenever the memory value changes

#### unsubscribe
```typescript
unsubscribe(subscriptionId: string): void
```
**Purpose**: Unsubscribe from changes by subscription ID  
**Parameters**:
- `subscriptionId: string` - The ID of the subscription to remove

**Returns**: `void`

#### hasSubscribers
```typescript
hasSubscribers(): boolean // TODO: not needed remove
```
**Purpose**: Check if this reference has any active subscribers  
**Parameters**: None  
**Returns**: `boolean` - true if there are active subscribers

#### notifySubscribers
```typescript
notifySubscribers(newValue: T | undefined, oldValue: T | undefined): void
```
**Purpose**: Notify all subscribers of a value change  
**Parameters**:
- `newValue: T | undefined` - The new value
- `oldValue: T | undefined` - The previous value

**Returns**: `void`  
**Notes**: Called internally by RuntimeMemory. Marked as @internal

---

## IEvent

**File**: `src/runtime/IEvent.ts`  
**Purpose**: Base interface for runtime events that can be handled by the system

### Properties

- `name: string` - Name/type of the event
- `timestamp: Date` - Timestamp when the event occurred
- `data?: any` - Additional event data (optional)

### Notes
This is a data-only interface representing events in the system.

---

## IEventHandler

**File**: `src/runtime/IEventHandler.ts`  
**Purpose**: Interface for handling runtime events and producing actions

### Properties

- `readonly id: string` - Unique identifier for this handler
- `readonly name: string` - Name of the handler for logging/debugging

### Methods

#### handler
```typescript
handler(event: IEvent, runtime: IScriptRuntime): IRuntimeAction[]  // TODO update the signature and do with the response type.  event handlers are thigns that generate action.
```
**Purpose**: Handles the event and returns a response indicating the result  
**Parameters**:
- `event: IEvent` - The event to handle
- `runtime: IScriptRuntime` - Script runtime context for event processing

**Returns**: `EventHandlerResponse` - Object describing handling state:
- `handled: boolean` - Whether this handler handled the event
- `abort: boolean` - Whether to continue processing with other handlers (false = continue, true = abort/break/stop)
- `actions: IRuntimeAction[]` - Actions to be performed by the runtime

**Notes**: Instead of separate canHandle and handle methods, implementors return a unified response

---

## IRuntimeBlockStrategy

**File**: `src/runtime/IRuntimeBlockStrategy.ts`  
**Purpose**: Strategy pattern for matching and compiling code statements into runtime blocks

### Methods

#### match
```typescript
match(statements: ICodeStatement[], runtime: IScriptRuntime): boolean
```
**Purpose**: Determines if this strategy can handle the given statements  
**Parameters**:
- `statements: ICodeStatement[]` - Array of code statements to evaluate
- `runtime: IScriptRuntime` - Script runtime context

**Returns**: `boolean` - true if this strategy can compile these statements

#### compile
```typescript
compile(statements: ICodeStatement[], runtime: IScriptRuntime): IRuntimeBlock
```
**Purpose**: Compiles code statements into a runtime block  
**Parameters**:
- `statements: ICodeStatement[]` - Array of code statements to compile
- `runtime: IScriptRuntime` - Script runtime context

**Returns**: `IRuntimeBlock` - Compiled runtime block ready for execution  
**Notes**: Only called after match() returns true

---

## IStackValidator

// TODO: not needed  remove this interface and the uses of it.

**File**: `src/runtime/IStackValidator.ts`  
**Purpose**: Validation behavior for RuntimeStack push/pop operations

### Methods

#### validatePush
```typescript
validatePush(block: IRuntimeBlock, currentDepth: number): void
```
**Purpose**: Validates a block before pushing to stack  
**Parameters**:
- `block: IRuntimeBlock` - The block to validate
- `currentDepth: number` - Current stack depth

**Returns**: `void`  
**Throws**: `TypeError` if validation fails  
**Performance**: Must complete in O(1) time  
**Contract Requirements**:
- Must check block is not null/undefined
- Must verify block has valid key
- Must verify block has sourceId
- Must check stack depth < 10
- Must throw TypeError on failure
- Must include stack state in error messages

#### validatePop
```typescript
validatePop(currentDepth: number): void
```
**Purpose**: Validates before popping from stack  
**Parameters**:
- `currentDepth: number` - Current stack depth

**Returns**: `void`  
**Throws**: `Error` if stack is empty  
**Performance**: Must complete in O(1) time  
**Contract Requirements**:
- Must check stack is not empty
- Must throw Error on failure

---

## Supporting Types

### EventHandlerResponse
**File**: `src/runtime/EventHandler.ts`

// TODO: remove this type as well.. it should not be needed anymore  the case of abort should be handled by new type of IRuntimeAction that pushes errors to a new Errors list in the runtime.  (if the errors lists has values the processing should be aborted for the next action.)

```typescript
type EventHandlerResponse = {
  handled: boolean;      // Whether this handler handled the event
  abort: boolean;        // Whether to continue processing (false = continue, true = abort)
  actions: IRuntimeAction[];  // Actions to be performed by the runtime
}
```

### `IMemorySubscription<T>`
**File**: `src/runtime/IMemoryReference.ts`

// TODO this needs an additional interface to be handled generically at the memory level `IMemorySubscription` that can be tracked in the `IMemoryReference` obejct  allowing this to be coded at the memory level and be generic for all memory refrence updtes.

```typescript
interface IMemorySubscription<T> {
  id: string;
  callback: (newValue: T | undefined, oldValue: T | undefined) => void;
  active: boolean;  // remove, the subscription is going to be in memory and would be removed if the unsubscriber calls it or be active till the memory is removed.
}
```

### SubscriptionOptions
**File**: `src/runtime/IMemoryReference.ts`

// TODO: remove this type, it is not needed.

```typescript
interface SubscriptionOptions {
  immediate?: boolean;   // Call callback immediately with current value
  throttle?: number;     // Min milliseconds between notifications
}
```

### BlockKey
**File**: `src/BlockKey.ts`

```typescript
class BlockKey {
  constructor(public readonly value: string = uuidv4())
  toString(): string
  valueOf(): string
  equals(other: BlockKey): boolean
}
```

### ICodeStatement
**File**: `src/CodeStatement.ts`

```typescript
interface ICodeStatement {
  id: number;
  parent?: number;
  children: number[][];
  fragments: ICodeFragment[];
  isLeaf?: boolean;
  meta: CodeMetadata;
}
```

### Nullable\<T>
**File**: `src/runtime/IRuntimeMemory.ts`

```typescript
type Nullable<T> = { [K in keyof T]: T[K] | null }
```

---

## Design Patterns and Principles

### Lifecycle Management
- **Constructor-Based Initialization**: Blocks are initialized during construction (preferred)
- **Consumer-Managed Disposal**: Consumers MUST call dispose() on blocks after popping from stack
- Performance requirement: All lifecycle methods must complete within 50ms

### Memory Management
- **Strategy-Owned Context**: BlockContext created by strategies before block creation
- **Constructor-Injected**: Memory references passed to behaviors during instantiation
- **Explicit Cleanup**: Consumer must call release() after block disposal

### Behavior Composition
- **Optional Hooks**: Implement only needed lifecycle methods (onPush, onNext, onPop)
- **Constructor-Configurable**: Behaviors accept arbitrary constructor args
- **Application-Time Context**: Every hook receives runtime and block instance

### Event Processing
- **Unified Response**: EventHandlers return single response object (no separate canHandle/handle)
- **Action Chain**: Events produce actions which modify runtime state
- **Handler Coordination**: abort flag controls handler chain continuation

---

## Refactoring Notes

**Add your feedback and planned changes below:**

<!-- Example:
### Proposed Change: [Name]
**Interface**: IRuntimeBehavior
**Method**: onPush
**Issue**: ...
**Proposed Solution**: ...
**Impact**: ...
-->

