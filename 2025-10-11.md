
```
/research the interface  

export interface IRuntimeBehavior {
  /** Called when the owning block is pushed onto the stack. May return initial events to emit. */
  onPush?(runtime: IScriptRuntime, block: IRuntimeBlock): IRuntimeAction[];

  /** Called when determining the next block after a child completes. Return a block to override. */
  onNext?(runtime: IScriptRuntime, block: IRuntimeBlock): IRuntimeAction[];

  /** Called right before the owning block is popped from the stack. */
  onPop?(runtime: IScriptRuntime, block: IRuntimeBlock): IRuntimeAction[];
}


see how each behavior uses each of the functions, waht the dependeicies with different memory refs are shared and what actiona under what conditions are the outcomes.

----

lets have a common template with the ability to easily re-configure the behaviors in the created classes.  The goal will be to align the different behaviors actions and momory allocation.

Crate a markdown document 
```

- Claude 45 - [[notes/runtime-behavior-architecture]]
- GLM 4.6 - [[notes/IRuntimeBehavior-Analysis-and-Template]]

---

```
I want to create a template document that allows me to quickly define how this should work, can you create a minimal input recreation of these to help me streamline building the relationships.  The basic rubrik should allow me to 
---
## Behavior

### Constructor Requires
- CodeStatement[]
- MemoryRef<Type> name 
- MemoryRef<Type> ...

### OnPush / OnNext / OnPop  (one heading for each)

- what validations are done
- what actions are created

### Additional Functions

- what functions are on the behaviors that are outside the scope of interface.

---

Anything that needs special definitions can be added as an addendum to the generated markdown document/

```

- Gemini 2.5 - [[behavior-definition-template]]

```
/research i need to understand the different actions the runtime currently support.  Give a high
  level overview of how the actinos are executed, what is avaliable to them, and what need to given by
  the behavior the creates it to populate the consturctors.   create the markdown docment for me to
  read though and makes changes on as design change feedback
```

```
lets make some changes to the document.. PushBlockAction shouldn't take IRuntimeBlock, it should
  take CodeStatement[]  (it will be responsible for calling the jit and pushing the output of the
  jit on the rimetime stack.
```

```
here are additional actions that shoudl be defined in the application lets update the document with
  suggested implementation  a user may update it late, but use the existing code to best figure out the
   classes that are not defined    - StartTimer(memoryRef, timeStamp)
  - StopTimer(memoryRef, timeStamp)
  - RegisterEvent(IEVentHandler)
  - UnregisterEvent(IEVentHandler)
  - PopBlock(timestamp)
  - NextBlock(timestamp)
```

Gemini 2.5 - [[research-notes-on-actions]]


```
create a new document under notes/ that walks though the interfaces associated  and identify all the
  methods and their input and types on each function.  I will be making edits to the document to
  feedback into change to the code base.
```

Gemini 2.5 - [[runtime-interfaces-analysis]]
Claude 4.5 - 